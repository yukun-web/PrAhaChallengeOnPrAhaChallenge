# コーディング規約

## 適用範囲

- `packages/*` を中心に、`apps/*` も含めて準拠します。

## 基本設定

### TypeScript

- `@ponp/typescript-config` を基準にします。
- `strict: true`、`noUncheckedIndexedAccess: true` を前提にします。
- `module: ESNext` / `moduleResolution: Bundler`、`noEmit: true` を前提にします。
- ESM を前提に `import` / `export` を使用し、`require` は使いません。

### ESLint

- `@ponp/eslint-config` を使用します。
- 主要ルール
  - `@typescript-eslint/consistent-type-imports`: 型のみの import は `import type` を使用。
  - `simple-import-sort/imports`: import の並びを自動整列。
  - `unused-imports/no-unused-imports`: 未使用の import を禁止。
  - `turbo/no-undeclared-env-vars`: 未宣言の環境変数利用は警告。

### Prettier

- ルートの `prettier` 実行結果に従います（独自設定は最小）。

## コーディングルール

### 書式と文体

- インデントは 2 スペースで統一します。
- 文末はセミコロンで統一します。
- 余計な空行は避け、論理ブロックごとに 1 行空けます。
- コメント・エラーメッセージ・TSDoc は日本語で統一します。
- 文体は「です/ます」調で統一します。
- 句読点は「、」「。」を使用します。
- 英語の専門語は必要に応じてそのまま使用します（例: `use-case`、`repository`）。
- TODO コメントは簡潔に書き、後続作業が分かるようにします。

### import / export

- import は `simple-import-sort` に従い、次の順に並べます。
  1. Node.js の組み込みモジュール（`node:`）
  2. 外部パッケージ（npm）
  3. プロジェクト内の相対パス
- 型のみの import は `import type` を使います。
- 相対 import の拡張子は **付けません**（`./foo` 形式）。
- パッケージの公開 API は `index.ts` から再 export します。
- パッケージ間の参照は基本的に公開 API（`@ponp/*`）を使います。

### 命名

- 型: `PascalCase`（例: `Participant`、`ParticipantId`）
- 関数: `camelCase`（例: `createEnrollUseCase`）
- 定数: `UPPER_SNAKE_CASE`（例: `TEST_PARTICIPANT_ID`）
- ファイル名
  - 機能名は `kebab-case`（例: `enroll.use-case.ts`）
  - テストは `*.test.ts`

### TSDoc

- 公開される関数・型・クラスには TSDoc を付けます。
- 1文目は要約。文末は「です/ます」調で統一します。
- `@param` と `@returns` は必須です。
- 例外を投げる場合は `@throws` を記述し、エラー型と条件を明記します。
- 補足は `@remarks` を使い、箇条書きの場合は `-` で統一します。
- 型エイリアス・定数も用途が自明でない場合は説明を付けます。
- プロパティの説明はフィールド直前の TSDoc で記述します。
- `@see` は関連する型や関数への参照として使います。
- 例示が必要なときは `@example` を付けます。

TSDoc の例:

```ts
/**
 * 参加者の入会ユースケースを作成します。
 *
 * @param dependencies 依存関係を指定します。
 * @returns 参加者の入会ユースケースを返します。
 * @throws {ValidationError} パラメータのいずれかが不正な場合にスローされます。
 * @throws {InfrastructureError} 保存に失敗した場合にスローされます。
 */
export const createEnrollUseCase = (dependencies: Dependencies): ExecuteEnrollUseCase => {
  // ...
};
```

### ドメイン / アプリケーション層の構成

- ドメイン識別子・値オブジェクトは公称型（`Nominal`）で表現します。
- バリデーションは `@ponp/fundamental` の `assert*` と `ValidationError` を用います。
  - **汎用的なバリデーション**（他でも発生しうるもの）は専用ヘルパーを使用します。該当するヘルパーがなければ `@ponp/fundamental` に追加します。
    - `assertUUID`: UUID 形式の検証
    - `assertNonEmptyString`: 空文字でないことの検証
    - `assertStringLength`: 文字列の最大長の検証
    - `assertEmail`: メールアドレス形式の検証
    - `assertIncludes`: 配列に含まれることの検証
  - **ドメイン固有のバリデーション**（そのドメインでしか発生しないもの）は `assert` を使用します。
- ユースケースは以下の構造を基本形とします。
  - `type Dependencies`
  - `type Params`
  - `export type ExecuteXxxUseCase`
  - `export const createXxxUseCase = (...) => ExecuteXxxUseCase`
- ファクトリ関数は `EntityName(value)` の形で作り、無効値は `ValidationError` を投げます。
- `generate` や `reconstruct` などの補助的な静的関数は、対象の関数にプロパティとして追加します。
- アプリケーション層の `port` は `type` で定義し、`infrastructure` はその実装に限定します。

#### 例: ドメイン（値オブジェクト）

```ts
/**
 * 参加者の識別子です。
 */
export type ParticipantId = Nominal<string, "ParticipantId">;

/**
 * 参加者の識別子のファクトリ関数です。
 *
 * @param value 参加者の識別子の文字列です。
 * @returns 指定された文字列が有効なら公称型にして返します。
 * @throws {ValidationError} 形式が不正な場合にスローされます。
 */
export const ParticipantId = (value: string): ParticipantId => {
  const error = new ValidationError({
    code: "INVALID_PARTICIPANT_ID_FORMAT",
    field: "ParticipantId",
    value,
  });
  assertUUID(value, error);
  return value as ParticipantId;
};

/**
 * 新しい参加者の識別子を生成します。
 *
 * @returns 新しい参加者の識別子を返します。
 */
ParticipantId.generate = () => ParticipantId(uuid());
```

#### 例: ユースケース

```ts
/**
 * 参加者の入会ユースケースが必要とする依存関係です。
 */
type Dependencies = {
  /**
   * 参加者を保存するリポジトリの関数です。
   */
  participantRepository: ParticipantRepository;
};

/**
 * 参加者の入会に必要なパラメータです。
 */
type EnrollParams = {
  /**
   * 入会する参加者の名前です。
   */
  name: string;

  /**
   * 入会する参加者のメールアドレスです。
   */
  email: string;
};

/**
 * 参加者の入会ユースケースの関数の型です。
 */
export type ExecuteEnrollUseCase = (params: EnrollParams) => Promise<void>;

/**
 * 参加者の入会ユースケースを作成します。
 *
 * @param dependencies 依存関係を指定します。
 * @returns 参加者の入会ユースケースを返します。
 */
export const createEnrollUseCase = (dependencies: Dependencies): ExecuteEnrollUseCase => {
  const { participantRepository } = dependencies;

  /**
   * 参加者の入会を扱うユースケースです。
   *
   * @param params 参加者の入会に必要なパラメータです。
   * @throws {ValidationError} パラメータが不正な場合にスローされます。
   * @throws {InfrastructureError} 保存に失敗した場合にスローされます。
   */
  const executeEnrollUseCase = async (params: EnrollParams) => {
    // 値オブジェクト変数名はプレフィックスなしで統一（email, id, name など）
    // 分割代入は使わず params.xxx から直接変換
    const name = ParticipantName(params.name);
    const email = ParticipantEmail(params.email);

    const [participant, enrolledEvent] = Participant.enroll({
      name,
      email,
    });

    console.log("event published", enrolledEvent); // TODO: イベントバスに乗せる
    await participantRepository.save(participant);
  };

  return executeEnrollUseCase;
};
```

#### 例: リポジトリ（infrastructure）

```ts
/**
 * 参加者リポジトリの Drizzle 実装です。
 *
 * @param dependencies 依存関係を指定します。
 * @returns 参加者リポジトリを返します。
 */
export const ParticipantDrizzleRepository = (
  dependencies: { db: Database },
): ParticipantRepository => {
  const { db } = dependencies;

  return {
    /**
     * 参加者を保存します。
     *
     * @param participant 保存する参加者です。
     * @throws {InfrastructureError} 保存に失敗した場合にスローされます。
     */
    async save(participant: Participant) {
      try {
        await upsertAggregateTable(db, participantsTable, participant);
      } catch (error) {
        throw new InfrastructureError("参加者の保存に失敗しました。", {
          code: "PARTICIPANT_SAVE_FAILED",
          cause: error,
        });
      }
    },
  };
};
```

### エラー設計

- ルール違反や不正値は `ValidationError` を使用します。
- ドメイン状態の矛盾は `DomainError` を使用します。
- 外部 I/O の失敗は `InfrastructureError` でラップし、`code` と `cause` を必ず指定します。
- `code` は英大文字・アンダースコアで統一します（例: `PARTICIPANT_NOT_FOUND`）。

#### 例: ドメインエラー

```ts
/**
 * 参加者が存在しない場合の例です。
 *
 * @throws {DomainError} 参加者が存在しない場合にスローされます。
 */
if (!participant) {
  throw new DomainError("指定した参加者が存在しません。", { code: "PARTICIPANT_NOT_FOUND" });
}
```

#### 例: インフラエラー

```ts
/**
 * 保存処理でのエラーラップの例です。
 *
 * @throws {InfrastructureError} 保存に失敗した場合にスローされます。
 */
try {
  await upsertAggregateTable(db, participantsTable, participant);
} catch (error) {
  throw new InfrastructureError("参加者の保存に失敗しました。", {
    code: "PARTICIPANT_SAVE_FAILED",
    cause: error,
  });
}
```

### ドメインイベント

- イベントは `type` で定義し、`PascalCase` の名前を使います。
- イベント名は「何が起きたか」を明確に表現します。
- 発行タイミングはユースケース内で明示し、送信先は TODO で残します。

#### 例: イベント定義

```ts
/**
 * 新しい参加者が入会したことを表すイベントです。
 */
export type ParticipantEnrolled = {
  /**
   * 入会した参加者の識別子です。
   */
  participantId: ParticipantId;

  /**
   * 入会した参加者の名前です。
   */
  name: ParticipantName;

  /**
   * 入会した日時です。
   */
  enrolledAt: Date;
};
```

#### 例: イベント発行

```ts
const [participant, enrolledEvent] = Participant.enroll({
  name: ParticipantName(name),
  email: ParticipantEmail(email),
});

console.log("event published", enrolledEvent); // TODO: イベントバスに乗せる
await participantRepository.save(participant);
```

### ロギングと例外伝播

- ログは必要最小限とし、業務上の重要な出来事のみを記録します。
- ログメッセージは日本語で統一し、状況が分かる文言にします。
- 例外は握りつぶさずに伝播させます。
- ユースケースはエラーを集約せず、ドメイン/インフラ層で定義された例外をそのまま伝播させます。
- `console.log` は暫定用途のみ許可し、置き換え時に削除します。

#### 例: ログと例外伝播

```ts
/**
 * イベント発行のログ例です。
 */
console.log("event published", enrolledEvent); // TODO: イベントバスに乗せる

/**
 * インフラエラーはラップしてスローします。
 */
try {
  await upsertAggregateTable(db, participantsTable, participant);
} catch (error) {
  throw new InfrastructureError("参加者の保存に失敗しました。", {
    code: "PARTICIPANT_SAVE_FAILED",
    cause: error,
  });
}
```

### テスト

- テストは `*.test.ts` とし、`vitest` を使用します。
- DB 連携テストは `@ponp/testing` の補助関数を利用します。
- `describe`/`test` の説明は日本語で統一します。
- テストデータは `TEST_` プレフィックスの定数で定義します。
- `beforeEach`/`beforeAll` を使い、セットアップは明示的に記述します。
- モックは `vitest` の `vi.fn()` を基本とします。
- エンティティのテストデータは `domain/testing` のヘルパー関数を使用します（例: `createDummyParticipant`）。
  - テスト内でエンティティのファクトリ関数（例: `Participant.enroll`）を直接呼び出さないでください。

#### 例: テスト

```ts
describe("createEnrollUseCase", () => {
  /**
   * テストに使用する参加者IDです。
   */
  const TEST_PARTICIPANT_ID = "87292b7f-ca43-4a41-b00f-7b73869d7026";

  /**
   * テストに使用する参加者の名前です。
   */
  const TEST_PARTICIPANT_NAME = "Taro Yamada";

  /**
   * テストに使用する参加者のメールアドレスです。
   */
  const TEST_PARTICIPANT_EMAIL = "taro@example.com";

  /**
   * ユースケースの実行関数です。
   */
  let executeUseCase: ExecuteEnrollUseCase;

  beforeEach(() => {
    vi.clearAllMocks();
    executeUseCase = createEnrollUseCase({ participantRepository: mockParticipantRepository });
  });

  test("参加者の入会時にリポジトリへ保存する", async () => {
    spyUuid(TEST_PARTICIPANT_ID);

    await executeUseCase({ name: TEST_PARTICIPANT_NAME, email: TEST_PARTICIPANT_EMAIL });

    expect(mockParticipantRepository.save).toHaveBeenCalledExactlyOnceWith({
      id: TEST_PARTICIPANT_ID,
      name: TEST_PARTICIPANT_NAME,
      email: TEST_PARTICIPANT_EMAIL,
      status: ParticipantStatus.ACTIVE,
    });
  });
});
```

### ファイル構成

- `domain`: エンティティ、値オブジェクト、ドメインイベント
- `application/use-case`: ユースケース
- `application/port`: リポジトリなどのインターフェース
- `infrastructure/adapter`: 永続化や外部連携の実装
- `*/testing`: テスト用のダミーやモック

## 修正リスト（不一致の統一）

現時点で修正対象はありません。

## コーディング規約の運用

- コードレビューで指摘された修正事項のうち、再発を防止できるものはこのコーディング規約に追加してください。
- 規約の追加・変更時は、既存コードとの一貫性を確認し、必要に応じて既存コードも修正してください。
