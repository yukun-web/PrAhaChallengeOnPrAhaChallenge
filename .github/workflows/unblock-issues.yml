name: Unblock Dependent Issues

on:
  issues:
    types: [closed]

jobs:
  unblock:
    if: github.event.issue.state_reason == 'completed'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Find and unblock dependent issues
        uses: actions/github-script@v7
        with:
          script: |
            const closedIssueNumber = context.issue.number;
            console.log(`Issue #${closedIssueNumber} was closed. Checking for dependent issues...`);

            // å…¨ã‚ªãƒ¼ãƒ—ãƒ³ Issue ã‚’å–å¾—
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            for (const issue of issues.data) {
              // Issue æœ¬æ–‡ã« "Blocked by #N" ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
              const blockedByPattern = new RegExp(`Blocked by[^\\n]*#${closedIssueNumber}\\b`, 'i');
              if (issue.body && blockedByPattern.test(issue.body)) {
                console.log(`Found dependent issue #${issue.number}`);

                // ä»–ã®ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ãŒã¾ã ã‚ã‚‹ã‹ç¢ºèª
                const blockedByMatches = issue.body.match(/Blocked by[^\n]*(#\d+)/gi) || [];
                const blockerNumbers = blockedByMatches
                  .flatMap(m => m.match(/#(\d+)/g) || [])
                  .map(n => parseInt(n.slice(1)));

                // ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸ Issue ä»¥å¤–ã®ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
                let stillBlocked = false;
                for (const blockerNum of blockerNumbers) {
                  if (blockerNum === closedIssueNumber) continue;
                  try {
                    const blocker = await github.rest.issues.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: blockerNum
                    });
                    if (blocker.data.state === 'open') {
                      console.log(`Issue #${issue.number} is still blocked by #${blockerNum}`);
                      stillBlocked = true;
                      break;
                    }
                  } catch (e) {
                    console.log(`Could not check issue #${blockerNum}: ${e.message}`);
                  }
                }

                // å…¨ãƒ–ãƒ­ãƒƒã‚«ãƒ¼è§£æ¶ˆãªã‚‰ parallel/ok ã«å¤‰æ›´
                if (!stillBlocked) {
                  const hasBlockedLabel = issue.labels.some(l => l.name === 'parallel/blocked');
                  if (hasBlockedLabel) {
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        name: 'parallel/blocked'
                      });
                    } catch (e) {
                      console.log(`Could not remove parallel/blocked label: ${e.message}`);
                    }

                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      labels: ['parallel/ok']
                    });
                    console.log(`Unblocked issue #${issue.number}`);

                    // ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ 
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `ğŸ”“ ä¾å­˜ã—ã¦ã„ãŸ #${closedIssueNumber} ãŒã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸãŸã‚ã€ã“ã® Issue ã¯ç€æ‰‹å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚`
                    });
                  }
                }
              }
            }
